"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.codeZero = exports.codeUppercaseF = exports.codeUppercaseE = exports.codeUppercaseA = exports.codeTab = exports.codeSpace = exports.codeSlash = exports.codeSemicolon = exports.codeReturn = exports.codeQuote = exports.codePlus = exports.codeOpeningBracket = exports.codeOpeningBrace = exports.codeOpenParenthesis = exports.codeNine = exports.codeNewline = exports.codeMinus = exports.codeLowercaseF = exports.codeLowercaseE = exports.codeLowercaseA = exports.codeFormFeed = exports.codeDoubleQuote = exports.codeDot = exports.codeComma = exports.codeColon = exports.codeClosingBracket = exports.codeClosingBrace = exports.codeCloseParenthesis = exports.codeBackspace = exports.codeBackslash = exports.codeAsterisk = void 0;
exports.endsWithCommaOrNewline = endsWithCommaOrNewline;
exports.insertBeforeLastWhitespace = insertBeforeLastWhitespace;
exports.isControlCharacter = isControlCharacter;
exports.isDelimiter = isDelimiter;
exports.isDelimiterExceptSlash = isDelimiterExceptSlash;
exports.isDigit = isDigit;
exports.isDoubleQuote = isDoubleQuote;
exports.isDoubleQuoteLike = isDoubleQuoteLike;
exports.isFunctionName = isFunctionName;
exports.isHex = isHex;
exports.isQuote = isQuote;
exports.isSingleQuote = isSingleQuote;
exports.isSingleQuoteLike = isSingleQuoteLike;
exports.isSpecialWhitespace = isSpecialWhitespace;
exports.isStartOfValue = isStartOfValue;
exports.isValidStringCharacter = isValidStringCharacter;
exports.isWhitespace = isWhitespace;
exports.removeAtIndex = removeAtIndex;
exports.stripLastOccurrence = stripLastOccurrence;
const codeBackslash = exports.codeBackslash = 0x5c; // "\"
const codeSlash = exports.codeSlash = 0x2f; // "/"
const codeAsterisk = exports.codeAsterisk = 0x2a; // "*"
const codeOpeningBrace = exports.codeOpeningBrace = 0x7b; // "{"
const codeClosingBrace = exports.codeClosingBrace = 0x7d; // "}"
const codeOpeningBracket = exports.codeOpeningBracket = 0x5b; // "["
const codeClosingBracket = exports.codeClosingBracket = 0x5d; // "]"
const codeOpenParenthesis = exports.codeOpenParenthesis = 0x28; // "("
const codeCloseParenthesis = exports.codeCloseParenthesis = 0x29; // ")"
const codeSpace = exports.codeSpace = 0x20; // " "
const codeNewline = exports.codeNewline = 0xa; // "\n"
const codeTab = exports.codeTab = 0x9; // "\t"
const codeReturn = exports.codeReturn = 0xd; // "\r"
const codeBackspace = exports.codeBackspace = 0x08; // "\b"
const codeFormFeed = exports.codeFormFeed = 0x0c; // "\f"
const codeDoubleQuote = exports.codeDoubleQuote = 0x0022; // "
const codePlus = exports.codePlus = 0x2b; // "+"
const codeMinus = exports.codeMinus = 0x2d; // "-"
const codeQuote = exports.codeQuote = 0x27; // "'"
const codeZero = exports.codeZero = 0x30; // "0"
const codeNine = exports.codeNine = 0x39; // "9"
const codeComma = exports.codeComma = 0x2c; // ","
const codeDot = exports.codeDot = 0x2e; // "." (dot, period)
const codeColon = exports.codeColon = 0x3a; // ":"
const codeSemicolon = exports.codeSemicolon = 0x3b; // ";"
const codeUppercaseA = exports.codeUppercaseA = 0x41; // "A"
const codeLowercaseA = exports.codeLowercaseA = 0x61; // "a"
const codeUppercaseE = exports.codeUppercaseE = 0x45; // "E"
const codeLowercaseE = exports.codeLowercaseE = 0x65; // "e"
const codeUppercaseF = exports.codeUppercaseF = 0x46; // "F"
const codeLowercaseF = exports.codeLowercaseF = 0x66; // "f"
const codeNonBreakingSpace = 0xa0;
const codeEnQuad = 0x2000;
const codeHairSpace = 0x200a;
const codeNarrowNoBreakSpace = 0x202f;
const codeMediumMathematicalSpace = 0x205f;
const codeIdeographicSpace = 0x3000;
const codeDoubleQuoteLeft = 0x201c; // “
const codeDoubleQuoteRight = 0x201d; // ”
const codeQuoteLeft = 0x2018; // ‘
const codeQuoteRight = 0x2019; // ’
const codeGraveAccent = 0x0060; // `
const codeAcuteAccent = 0x00b4; // ´

function isHex(code) {
  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;
}
function isDigit(code) {
  return code >= codeZero && code <= codeNine;
}
function isValidStringCharacter(code) {
  return code >= 0x20 && code <= 0x10ffff;
}
function isDelimiter(char) {
  return regexDelimiter.test(char);
}
const regexDelimiter = /^[,:[\]/{}()\n+]$/;
function isDelimiterExceptSlash(char) {
  return isDelimiter(char) && char !== '/';
}
function isStartOfValue(char) {
  return regexStartOfValue.test(char) || char && isQuote(char.charCodeAt(0));
}

// alpha, number, minus, or opening bracket or brace
const regexStartOfValue = /^[[{\w-]$/;
function isControlCharacter(code) {
  return code === codeNewline || code === codeReturn || code === codeTab || code === codeBackspace || code === codeFormFeed;
}

/**
 * Check if the given character is a whitespace character like space, tab, or
 * newline
 */
function isWhitespace(code) {
  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;
}

/**
 * Check if the given character is a special whitespace character, some
 * unicode variant
 */
function isSpecialWhitespace(code) {
  return code === codeNonBreakingSpace || code >= codeEnQuad && code <= codeHairSpace || code === codeNarrowNoBreakSpace || code === codeMediumMathematicalSpace || code === codeIdeographicSpace;
}

/**
 * Test whether the given character is a quote or double quote character.
 * Also tests for special variants of quotes.
 */
function isQuote(code) {
  // the first check double quotes, since that occurs most often
  return isDoubleQuoteLike(code) || isSingleQuoteLike(code);
}

/**
 * Test whether the given character is a double quote character.
 * Also tests for special variants of double quotes.
 */
function isDoubleQuoteLike(code) {
  // the first check double quotes, since that occurs most often
  return code === codeDoubleQuote || code === codeDoubleQuoteLeft || code === codeDoubleQuoteRight;
}

/**
 * Test whether the given character is a double quote character.
 * Does NOT test for special variants of double quotes.
 */
function isDoubleQuote(code) {
  return code === codeDoubleQuote;
}

/**
 * Test whether the given character is a single quote character.
 * Also tests for special variants of single quotes.
 */
function isSingleQuoteLike(code) {
  return code === codeQuote || code === codeQuoteLeft || code === codeQuoteRight || code === codeGraveAccent || code === codeAcuteAccent;
}

/**
 * Test whether the given character is a single quote character.
 * Does NOT test for special variants of single quotes.
 */
function isSingleQuote(code) {
  return code === codeQuote;
}

/**
 * Strip last occurrence of textToStrip from text
 */
function stripLastOccurrence(text, textToStrip) {
  let stripRemainingText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const index = text.lastIndexOf(textToStrip);
  return index !== -1 ? text.substring(0, index) + (stripRemainingText ? '' : text.substring(index + 1)) : text;
}
function insertBeforeLastWhitespace(text, textToInsert) {
  let index = text.length;
  if (!isWhitespace(text.charCodeAt(index - 1))) {
    // no trailing whitespaces
    return text + textToInsert;
  }
  while (isWhitespace(text.charCodeAt(index - 1))) {
    index--;
  }
  return text.substring(0, index) + textToInsert + text.substring(index);
}
function removeAtIndex(text, start, count) {
  return text.substring(0, start) + text.substring(start + count);
}

/**
 * Test whether a string ends with a newline or comma character and optional whitespace
 */
function endsWithCommaOrNewline(text) {
  return /[,\n][ \t\r]*$/.test(text);
}
function isFunctionName(text) {
  return /^\w+$/.test(text);
}
//# sourceMappingURL=stringUtils.js.map